// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod altered_cards {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum FactionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Faction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Faction<'a> {
  type Inner = Faction<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Faction<'a> {
  pub const VT_REFERENCE: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_COLOR: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Faction { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FactionArgs<'args>
  ) -> flatbuffers::WIPOffset<Faction<'bldr>> {
    let mut builder = FactionBuilder::new(_fbb);
    if let Some(x) = args.color { builder.add_color(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.reference { builder.add_reference(x); }
    builder.finish()
  }


  #[inline]
  pub fn reference(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Faction::VT_REFERENCE, None)
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Faction::VT_NAME, None)
  }
  #[inline]
  pub fn color(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Faction::VT_COLOR, None)
  }
}

impl flatbuffers::Verifiable for Faction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reference", Self::VT_REFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("color", Self::VT_COLOR, false)?
     .finish();
    Ok(())
  }
}
pub struct FactionArgs<'a> {
    pub reference: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub color: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for FactionArgs<'a> {
  #[inline]
  fn default() -> Self {
    FactionArgs {
      reference: None,
      name: None,
      color: None,
    }
  }
}

pub struct FactionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FactionBuilder<'a, 'b> {
  #[inline]
  pub fn add_reference(&mut self, reference: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Faction::VT_REFERENCE, reference);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Faction::VT_NAME, name);
  }
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Faction::VT_COLOR, color);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FactionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FactionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Faction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Faction<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Faction");
      ds.field("reference", &self.reference());
      ds.field("name", &self.name());
      ds.field("color", &self.color());
      ds.finish()
  }
}
pub enum RarityOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Rarity<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Rarity<'a> {
  type Inner = Rarity<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Rarity<'a> {
  pub const VT_REFERENCE: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Rarity { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RarityArgs<'args>
  ) -> flatbuffers::WIPOffset<Rarity<'bldr>> {
    let mut builder = RarityBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.reference { builder.add_reference(x); }
    builder.finish()
  }


  #[inline]
  pub fn reference(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Rarity::VT_REFERENCE, None)
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Rarity::VT_NAME, None)
  }
}

impl flatbuffers::Verifiable for Rarity<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reference", Self::VT_REFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct RarityArgs<'a> {
    pub reference: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for RarityArgs<'a> {
  #[inline]
  fn default() -> Self {
    RarityArgs {
      reference: None,
      name: None,
    }
  }
}

pub struct RarityBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RarityBuilder<'a, 'b> {
  #[inline]
  pub fn add_reference(&mut self, reference: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Rarity::VT_REFERENCE, reference);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Rarity::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RarityBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RarityBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Rarity<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Rarity<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Rarity");
      ds.field("reference", &self.reference());
      ds.field("name", &self.name());
      ds.finish()
  }
}
pub enum CardTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CardType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CardType<'a> {
  type Inner = CardType<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> CardType<'a> {
  pub const VT_REFERENCE: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CardType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CardTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<CardType<'bldr>> {
    let mut builder = CardTypeBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.reference { builder.add_reference(x); }
    builder.finish()
  }


  #[inline]
  pub fn reference(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CardType::VT_REFERENCE, None)
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CardType::VT_NAME, None)
  }
}

impl flatbuffers::Verifiable for CardType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reference", Self::VT_REFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct CardTypeArgs<'a> {
    pub reference: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CardTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    CardTypeArgs {
      reference: None,
      name: None,
    }
  }
}

pub struct CardTypeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CardTypeBuilder<'a, 'b> {
  #[inline]
  pub fn add_reference(&mut self, reference: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CardType::VT_REFERENCE, reference);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CardType::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CardTypeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CardTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CardType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CardType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CardType");
      ds.field("reference", &self.reference());
      ds.field("name", &self.name());
      ds.finish()
  }
}
pub enum PowerStatsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PowerStats<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PowerStats<'a> {
  type Inner = PowerStats<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> PowerStats<'a> {
  pub const VT_MOUNTAIN: flatbuffers::VOffsetT = 4;
  pub const VT_OCEAN: flatbuffers::VOffsetT = 6;
  pub const VT_FOREST: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PowerStats { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PowerStatsArgs
  ) -> flatbuffers::WIPOffset<PowerStats<'bldr>> {
    let mut builder = PowerStatsBuilder::new(_fbb);
    builder.add_forest(args.forest);
    builder.add_ocean(args.ocean);
    builder.add_mountain(args.mountain);
    builder.finish()
  }


  #[inline]
  pub fn mountain(&self) -> u8 {
    self._tab.get::<u8>(PowerStats::VT_MOUNTAIN, Some(0)).unwrap()
  }
  #[inline]
  pub fn ocean(&self) -> u8 {
    self._tab.get::<u8>(PowerStats::VT_OCEAN, Some(0)).unwrap()
  }
  #[inline]
  pub fn forest(&self) -> u8 {
    self._tab.get::<u8>(PowerStats::VT_FOREST, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for PowerStats<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("mountain", Self::VT_MOUNTAIN, false)?
     .visit_field::<u8>("ocean", Self::VT_OCEAN, false)?
     .visit_field::<u8>("forest", Self::VT_FOREST, false)?
     .finish();
    Ok(())
  }
}
pub struct PowerStatsArgs {
    pub mountain: u8,
    pub ocean: u8,
    pub forest: u8,
}
impl<'a> Default for PowerStatsArgs {
  #[inline]
  fn default() -> Self {
    PowerStatsArgs {
      mountain: 0,
      ocean: 0,
      forest: 0,
    }
  }
}

pub struct PowerStatsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PowerStatsBuilder<'a, 'b> {
  #[inline]
  pub fn add_mountain(&mut self, mountain: u8) {
    self.fbb_.push_slot::<u8>(PowerStats::VT_MOUNTAIN, mountain, 0);
  }
  #[inline]
  pub fn add_ocean(&mut self, ocean: u8) {
    self.fbb_.push_slot::<u8>(PowerStats::VT_OCEAN, ocean, 0);
  }
  #[inline]
  pub fn add_forest(&mut self, forest: u8) {
    self.fbb_.push_slot::<u8>(PowerStats::VT_FOREST, forest, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PowerStatsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PowerStatsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PowerStats<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PowerStats<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PowerStats");
      ds.field("mountain", &self.mountain());
      ds.field("ocean", &self.ocean());
      ds.field("forest", &self.forest());
      ds.finish()
  }
}
pub enum CardOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Card<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Card<'a> {
  type Inner = Card<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Card<'a> {
  pub const VT_REFERENCE: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_FACTION_IDX: flatbuffers::VOffsetT = 8;
  pub const VT_RARITY_IDX: flatbuffers::VOffsetT = 10;
  pub const VT_CARD_TYPE_IDX: flatbuffers::VOffsetT = 12;
  pub const VT_MAIN_COST: flatbuffers::VOffsetT = 14;
  pub const VT_RECALL_COST: flatbuffers::VOffsetT = 16;
  pub const VT_POWER: flatbuffers::VOffsetT = 18;
  pub const VT_IMAGE_PATH: flatbuffers::VOffsetT = 20;
  pub const VT_QR_URL: flatbuffers::VOffsetT = 22;
  pub const VT_IS_SUSPENDED: flatbuffers::VOffsetT = 24;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Card { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CardArgs<'args>
  ) -> flatbuffers::WIPOffset<Card<'bldr>> {
    let mut builder = CardBuilder::new(_fbb);
    if let Some(x) = args.qr_url { builder.add_qr_url(x); }
    if let Some(x) = args.image_path { builder.add_image_path(x); }
    if let Some(x) = args.power { builder.add_power(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.reference { builder.add_reference(x); }
    builder.add_is_suspended(args.is_suspended);
    builder.add_recall_cost(args.recall_cost);
    builder.add_main_cost(args.main_cost);
    builder.add_card_type_idx(args.card_type_idx);
    builder.add_rarity_idx(args.rarity_idx);
    builder.add_faction_idx(args.faction_idx);
    builder.finish()
  }


  #[inline]
  pub fn reference(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Card::VT_REFERENCE, None)
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Card::VT_NAME, None)
  }
  #[inline]
  pub fn faction_idx(&self) -> u8 {
    self._tab.get::<u8>(Card::VT_FACTION_IDX, Some(0)).unwrap()
  }
  #[inline]
  pub fn rarity_idx(&self) -> u8 {
    self._tab.get::<u8>(Card::VT_RARITY_IDX, Some(0)).unwrap()
  }
  #[inline]
  pub fn card_type_idx(&self) -> u8 {
    self._tab.get::<u8>(Card::VT_CARD_TYPE_IDX, Some(0)).unwrap()
  }
  #[inline]
  pub fn main_cost(&self) -> u8 {
    self._tab.get::<u8>(Card::VT_MAIN_COST, Some(0)).unwrap()
  }
  #[inline]
  pub fn recall_cost(&self) -> u8 {
    self._tab.get::<u8>(Card::VT_RECALL_COST, Some(0)).unwrap()
  }
  #[inline]
  pub fn power(&self) -> Option<PowerStats<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<PowerStats>>(Card::VT_POWER, None)
  }
  #[inline]
  pub fn image_path(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Card::VT_IMAGE_PATH, None)
  }
  #[inline]
  pub fn qr_url(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Card::VT_QR_URL, None)
  }
  #[inline]
  pub fn is_suspended(&self) -> bool {
    self._tab.get::<bool>(Card::VT_IS_SUSPENDED, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for Card<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reference", Self::VT_REFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u8>("faction_idx", Self::VT_FACTION_IDX, false)?
     .visit_field::<u8>("rarity_idx", Self::VT_RARITY_IDX, false)?
     .visit_field::<u8>("card_type_idx", Self::VT_CARD_TYPE_IDX, false)?
     .visit_field::<u8>("main_cost", Self::VT_MAIN_COST, false)?
     .visit_field::<u8>("recall_cost", Self::VT_RECALL_COST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PowerStats>>("power", Self::VT_POWER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image_path", Self::VT_IMAGE_PATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("qr_url", Self::VT_QR_URL, false)?
     .visit_field::<bool>("is_suspended", Self::VT_IS_SUSPENDED, false)?
     .finish();
    Ok(())
  }
}
pub struct CardArgs<'a> {
    pub reference: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub faction_idx: u8,
    pub rarity_idx: u8,
    pub card_type_idx: u8,
    pub main_cost: u8,
    pub recall_cost: u8,
    pub power: Option<flatbuffers::WIPOffset<PowerStats<'a>>>,
    pub image_path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub qr_url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_suspended: bool,
}
impl<'a> Default for CardArgs<'a> {
  #[inline]
  fn default() -> Self {
    CardArgs {
      reference: None,
      name: None,
      faction_idx: 0,
      rarity_idx: 0,
      card_type_idx: 0,
      main_cost: 0,
      recall_cost: 0,
      power: None,
      image_path: None,
      qr_url: None,
      is_suspended: false,
    }
  }
}

pub struct CardBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CardBuilder<'a, 'b> {
  #[inline]
  pub fn add_reference(&mut self, reference: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Card::VT_REFERENCE, reference);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Card::VT_NAME, name);
  }
  #[inline]
  pub fn add_faction_idx(&mut self, faction_idx: u8) {
    self.fbb_.push_slot::<u8>(Card::VT_FACTION_IDX, faction_idx, 0);
  }
  #[inline]
  pub fn add_rarity_idx(&mut self, rarity_idx: u8) {
    self.fbb_.push_slot::<u8>(Card::VT_RARITY_IDX, rarity_idx, 0);
  }
  #[inline]
  pub fn add_card_type_idx(&mut self, card_type_idx: u8) {
    self.fbb_.push_slot::<u8>(Card::VT_CARD_TYPE_IDX, card_type_idx, 0);
  }
  #[inline]
  pub fn add_main_cost(&mut self, main_cost: u8) {
    self.fbb_.push_slot::<u8>(Card::VT_MAIN_COST, main_cost, 0);
  }
  #[inline]
  pub fn add_recall_cost(&mut self, recall_cost: u8) {
    self.fbb_.push_slot::<u8>(Card::VT_RECALL_COST, recall_cost, 0);
  }
  #[inline]
  pub fn add_power(&mut self, power: flatbuffers::WIPOffset<PowerStats<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PowerStats>>(Card::VT_POWER, power);
  }
  #[inline]
  pub fn add_image_path(&mut self, image_path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Card::VT_IMAGE_PATH, image_path);
  }
  #[inline]
  pub fn add_qr_url(&mut self, qr_url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Card::VT_QR_URL, qr_url);
  }
  #[inline]
  pub fn add_is_suspended(&mut self, is_suspended: bool) {
    self.fbb_.push_slot::<bool>(Card::VT_IS_SUSPENDED, is_suspended, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CardBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CardBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Card<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Card<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Card");
      ds.field("reference", &self.reference());
      ds.field("name", &self.name());
      ds.field("faction_idx", &self.faction_idx());
      ds.field("rarity_idx", &self.rarity_idx());
      ds.field("card_type_idx", &self.card_type_idx());
      ds.field("main_cost", &self.main_cost());
      ds.field("recall_cost", &self.recall_cost());
      ds.field("power", &self.power());
      ds.field("image_path", &self.image_path());
      ds.field("qr_url", &self.qr_url());
      ds.field("is_suspended", &self.is_suspended());
      ds.finish()
  }
}
pub enum CardDatabaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CardDatabase<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CardDatabase<'a> {
  type Inner = CardDatabase<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> CardDatabase<'a> {
  pub const VT_FACTIONS: flatbuffers::VOffsetT = 4;
  pub const VT_RARITIES: flatbuffers::VOffsetT = 6;
  pub const VT_CARD_TYPES: flatbuffers::VOffsetT = 8;
  pub const VT_CARDS: flatbuffers::VOffsetT = 10;
  pub const VT_GENERATED_AT_UTC: flatbuffers::VOffsetT = 12;
  pub const VT_SCRIPT_VERSION: flatbuffers::VOffsetT = 14;
  pub const VT_TOTAL_CARDS: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CardDatabase { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CardDatabaseArgs<'args>
  ) -> flatbuffers::WIPOffset<CardDatabase<'bldr>> {
    let mut builder = CardDatabaseBuilder::new(_fbb);
    builder.add_total_cards(args.total_cards);
    if let Some(x) = args.script_version { builder.add_script_version(x); }
    if let Some(x) = args.generated_at_utc { builder.add_generated_at_utc(x); }
    if let Some(x) = args.cards { builder.add_cards(x); }
    if let Some(x) = args.card_types { builder.add_card_types(x); }
    if let Some(x) = args.rarities { builder.add_rarities(x); }
    if let Some(x) = args.factions { builder.add_factions(x); }
    builder.finish()
  }


  #[inline]
  pub fn factions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Faction<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Faction>>>>(CardDatabase::VT_FACTIONS, None)
  }
  #[inline]
  pub fn rarities(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Rarity<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Rarity>>>>(CardDatabase::VT_RARITIES, None)
  }
  #[inline]
  pub fn card_types(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CardType<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CardType>>>>(CardDatabase::VT_CARD_TYPES, None)
  }
  #[inline]
  pub fn cards(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Card<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Card>>>>(CardDatabase::VT_CARDS, None)
  }
  #[inline]
  pub fn generated_at_utc(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CardDatabase::VT_GENERATED_AT_UTC, None)
  }
  #[inline]
  pub fn script_version(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CardDatabase::VT_SCRIPT_VERSION, None)
  }
  #[inline]
  pub fn total_cards(&self) -> u32 {
    self._tab.get::<u32>(CardDatabase::VT_TOTAL_CARDS, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for CardDatabase<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Faction>>>>("factions", Self::VT_FACTIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Rarity>>>>("rarities", Self::VT_RARITIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CardType>>>>("card_types", Self::VT_CARD_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Card>>>>("cards", Self::VT_CARDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("generated_at_utc", Self::VT_GENERATED_AT_UTC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("script_version", Self::VT_SCRIPT_VERSION, false)?
     .visit_field::<u32>("total_cards", Self::VT_TOTAL_CARDS, false)?
     .finish();
    Ok(())
  }
}
pub struct CardDatabaseArgs<'a> {
    pub factions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Faction<'a>>>>>,
    pub rarities: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Rarity<'a>>>>>,
    pub card_types: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CardType<'a>>>>>,
    pub cards: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Card<'a>>>>>,
    pub generated_at_utc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub script_version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub total_cards: u32,
}
impl<'a> Default for CardDatabaseArgs<'a> {
  #[inline]
  fn default() -> Self {
    CardDatabaseArgs {
      factions: None,
      rarities: None,
      card_types: None,
      cards: None,
      generated_at_utc: None,
      script_version: None,
      total_cards: 0,
    }
  }
}

pub struct CardDatabaseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CardDatabaseBuilder<'a, 'b> {
  #[inline]
  pub fn add_factions(&mut self, factions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Faction<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CardDatabase::VT_FACTIONS, factions);
  }
  #[inline]
  pub fn add_rarities(&mut self, rarities: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Rarity<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CardDatabase::VT_RARITIES, rarities);
  }
  #[inline]
  pub fn add_card_types(&mut self, card_types: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CardType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CardDatabase::VT_CARD_TYPES, card_types);
  }
  #[inline]
  pub fn add_cards(&mut self, cards: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Card<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CardDatabase::VT_CARDS, cards);
  }
  #[inline]
  pub fn add_generated_at_utc(&mut self, generated_at_utc: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CardDatabase::VT_GENERATED_AT_UTC, generated_at_utc);
  }
  #[inline]
  pub fn add_script_version(&mut self, script_version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CardDatabase::VT_SCRIPT_VERSION, script_version);
  }
  #[inline]
  pub fn add_total_cards(&mut self, total_cards: u32) {
    self.fbb_.push_slot::<u32>(CardDatabase::VT_TOTAL_CARDS, total_cards, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CardDatabaseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CardDatabaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CardDatabase<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CardDatabase<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CardDatabase");
      ds.field("factions", &self.factions());
      ds.field("rarities", &self.rarities());
      ds.field("card_types", &self.card_types());
      ds.field("cards", &self.cards());
      ds.field("generated_at_utc", &self.generated_at_utc());
      ds.field("script_version", &self.script_version());
      ds.field("total_cards", &self.total_cards());
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_card_database<'a>(buf: &'a [u8]) -> CardDatabase<'a> {
  unsafe { flatbuffers::root_unchecked::<CardDatabase<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_card_database<'a>(buf: &'a [u8]) -> CardDatabase<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<CardDatabase<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `CardDatabase`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_card_database_unchecked`.
pub fn root_as_card_database(buf: &[u8]) -> Result<CardDatabase, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<CardDatabase>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `CardDatabase` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_card_database_unchecked`.
pub fn size_prefixed_root_as_card_database(buf: &[u8]) -> Result<CardDatabase, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<CardDatabase>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `CardDatabase` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_card_database_unchecked`.
pub fn root_as_card_database_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CardDatabase<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<CardDatabase<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `CardDatabase` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_card_database_unchecked`.
pub fn size_prefixed_root_as_card_database_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CardDatabase<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<CardDatabase<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a CardDatabase and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `CardDatabase`.
pub unsafe fn root_as_card_database_unchecked(buf: &[u8]) -> CardDatabase {
  flatbuffers::root_unchecked::<CardDatabase>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed CardDatabase and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `CardDatabase`.
pub unsafe fn size_prefixed_root_as_card_database_unchecked(buf: &[u8]) -> CardDatabase {
  flatbuffers::size_prefixed_root_unchecked::<CardDatabase>(buf)
}
#[inline]
pub fn finish_card_database_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<CardDatabase<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_card_database_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<CardDatabase<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod AlteredCards

